{
  pkgs,
  nixos-anywhere ? null,
  ...
}: let
  # Helper library with usefull functions
  lib = pkgs.writeShellScript "script-lib" ''
    function require_hostname() {
      if [ $# -eq 0 ]; then
        echo "Error: Hostname required"
        echo "Usage: $(basename "$0") HOSTNAME"
        exit 1
      fi
    }

    function validate_hostname() {
      local -r hostname="$1"
      if ! nix eval .#hosts."$hostname" &>/dev/null; then
        echo "Error: Unknown host '$hostname'"
        echo "Available hosts:"
        nix eval .#hosts --apply 'hosts: builtins.attrNames hosts' --json | jq -r '.[]' | sed 's/^/  - /'
        exit 1
      fi
    }

    # Ask for password with confirmation
    function ask_for_token() {
      local -r token_name="''${1:-password}"

      while true; do
        echo -n "Enter $token_name (empty to be autogenerated): " >&2
        local token
        read -rs token
        echo >&2

        if [ -z "$token" ]; then
          echo "WARN: $token_name is empty" >&2
          echo ""
          return
        fi

        echo -n "Confirm $token_name: " >&2
        local token_confirm
        read -rs token_confirm
        echo >&2

        if [ "$token" = "$token_confirm" ]; then
          break
        fi
        echo "ERROR: $token_name do not match. Please try again." >&2
      done

      echo -n "$token"
    }

    # Generate random password
    function generate_password() {
      echo "Generating password" >&2

      local password
      password=$(head -c 12 /dev/urandom | base64 | tr -d '/+=' | head -c 16)

      echo -n "$password"
    }
  '';
in {
  add-ssh-key =
    pkgs.writeShellApplication
    {
      name = "add-ssh-key";
      runtimeInputs = with pkgs; [
        coreutils
        openssh
        gnused
        gnupg
      ];
      text = ''
        # shellcheck source=/dev/null
        source ${lib}

        readonly KEYTYPE="ed25519"
        readonly KEYS_DIR="$HOME/.ssh"
        readonly AUTH_KEYS_FILE="ssh-authorized-keys.pub"

        function generate_ssh_keys() {
          local -r key_name="$1"
          local -r key_password="$2"

          local -r key_file="$KEYS_DIR/$key_name"

          # Create .ssh directory if it doesn't exist
          mkdir -p "$KEYS_DIR"
          chmod 700 "$KEYS_DIR"

          # Generate the SSH key pair with password protection
          echo "Generating new SSH key pair with password protection" >&2
          ssh-keygen -t "$KEYTYPE" -f "$key_file" -C "$key_name" -N "$key_password" >&2

          echo "$key_file"
        }

        function export_keys() {
          local -r auth_keys_path="$1"
          local -r key_file="$2"

          # Ensure authorized keys file directory exists
          mkdir -p "$(dirname "$auth_keys_path")"

          # Add public key to authorized keys file
          echo "Adding public key to $auth_keys_path" >&2
          cat "$key_file.pub" >> "$auth_keys_path"
        }

        function commit_keys() {
          local -r auth_keys_path="$1"
          local -r target="$2"
          local -r username="$3"
          local -r hostname="$4"

          echo "Committing changes to $auth_keys_path" >&2
          git add "$auth_keys_path"
          git commit -m "$target: Authorize $username-$hostname ssh key"
        }

        function main() {
          if [ $# -ne 1 ]; then
            echo "Usage: add-ssh-key TARGET"
            exit 1
          fi
          local -r target="$1"

          local -r hostname="$(hostname)"
          local -r username="$(whoami)"

          local -r key_name="$username-$hostname-$target"
          local -r auth_keys_path="hosts/$target/$AUTH_KEYS_FILE"

          local -r key_password=$(ask_for_token "key password")
          local -r key_file=$(generate_ssh_keys "$key_name" "$key_password")
          export_keys "$auth_keys_path" "$key_file"
          commit_keys "$auth_keys_path" "$target" "$username" "$hostname"

          echo "SSH key pair generated successfully"
        }

        main "$@"
      '';
    };

  # Builds NixOS sdcard image that can be used for aarch64
  # Raspberry Pi machines.
  # `nix run .#build-sdcard hostname`
  build-sdcard =
    pkgs.writeShellApplication
    {
      name = "build-sdcard";
      runtimeInputs = with pkgs; [
        coreutils
        wireguard-tools
      ];
      text = ''
        # shellcheck source=/dev/null
        source ${lib}

        require_hostname "$@"
        readonly HOSTNAME="$1"
        validate_hostname "$HOSTNAME"

        readonly IMAGE_NAME="$HOSTNAME-sdcard"

        echo "Building image for host: $HOSTNAME"

        # Build the image - clean and simple
        nix build ".#image.sdcard.$HOSTNAME" \
          -o "$IMAGE_NAME"

        echo "Image built successfully: $IMAGE_NAME"
      '';
    };

  # Builds iso image for USB stick that can be used to boot
  # and install the NixOS system on x86-64 machine.
  build-installer =
    pkgs.writeShellApplication
    {
      name = "build-installer";
      runtimeInputs = with pkgs; [
        coreutils
        curl
        jq
      ];
      text = ''
        # shellcheck source=/dev/null
        source ${lib}

        readonly HOSTNAME="iso"

        # Check if NETBIRD_API_TOKEN is set, prompt if not
        if [ -z "''${NETBIRD_API_TOKEN:-}" ]; then
          NETBIRD_API_TOKEN=$(ask_for_token "Netbird API token")

          if [ -z "$NETBIRD_API_TOKEN" ]; then
            echo "ERROR: Netbird API token is required" >&2
            exit 1
          fi

          export NETBIRD_API_TOKEN
        fi

        echo "Generating Netbird setup key for $HOSTNAME..."

        # Generate reusable setup key for ISO installer (ephemeral peers)
        # ISO can be booted multiple times, each boot creates ephemeral peer
        api_response=$(curl -s -X POST https://api.netbird.io/api/setup-keys \
          -H "Authorization: Token $NETBIRD_API_TOKEN" \
          -H "Content-Type: application/json" \
          --data-raw "{\"name\":\"$HOSTNAME\",\"type\":\"reusable\",\"expires_in\":2592000,\"auto_groups\":[],\"usage_limit\":0,\"ephemeral\":true}" 2>&1) || {
          echo "ERROR: Failed to create Netbird setup key via API" >&2
          echo "Response: $api_response" >&2
          exit 1
        }

        # Extract the key from the API response
        NETBIRD_SETUP_KEY=$(echo "$api_response" | jq -r '.key')

        # Validate that we got a non-empty key
        if [ -z "$NETBIRD_SETUP_KEY" ] || [ "$NETBIRD_SETUP_KEY" = "null" ]; then
          echo "ERROR: Netbird setup key is empty or invalid" >&2
          echo "API Response: $api_response" >&2
          exit 1
        fi

        export NETBIRD_SETUP_KEY

        # Build the image using nixos-generators via flake output
        # Pass the setup key via environment variable to Nix
        nix build ".#image.installer" \
          --impure \
          -o "iso-image"

        echo "ISO image built successfully: iso-image"

        # Clean up setup key
        unset NETBIRD_SETUP_KEY

        echo "Setup key securely deleted, build complete."
      '';
    };

  # Deploy changes remotely. It is expected that the host
  # is running the NixOS and is accessible over network.
  # `nix run .#deploy-config hostname`
  deploy-config =
    pkgs.writeShellApplication
    {
      name = "deploy-config";
      runtimeInputs = with pkgs; [
        deploy-rs
        openssh
      ];
      text = ''
        # shellcheck source=/dev/null
        source ${lib}

        require_hostname "$@"

        readonly HOSTNAME="$1"
        shift

        validate_hostname "$HOSTNAME"

        # Run deploy-rs
        echo "Deploying to $HOSTNAME..."

        deploy \
          --skip-checks \
          ".#$HOSTNAME" "$@"

        # Workaround for deploy-rs issue #153: /run/current-system not updated
        # https://github.com/serokell/deploy-rs/issues/153
        echo "Updating /run/current-system symlink..."
        ssh "$HOSTNAME.krejci.io" "sudo ln -sfn /nix/var/nix/profiles/system /run/current-system"
        echo "Deployment complete!"
      '';
    };

  # Install nixos remotely. It is expected that the host
  # is booted via USB stick and accesible on iso.krejci.io
  # `nix run .#nixos-install`
  nixos-install =
    pkgs.writeShellApplication
    {
      name = "nixos-install";
      runtimeInputs = with pkgs; [
        coreutils
        util-linux
        gnused
        nixos-anywhere
        iputils
        openssh
        jq
        curl
      ];
      text = ''
        # shellcheck source=/dev/null
        source ${lib}

        trap cleanup EXIT INT TERM

        readonly TARGET="iso.krejci.io"
        # The password must be persistent, it is used to enroll TPM key
        # during the first boot and then it is erased
        readonly REMOTE_DISK_PASSWORD_FOLDER="/var/lib"
        readonly REMOTE_DISK_PASSWORD_PATH="$REMOTE_DISK_PASSWORD_FOLDER/disk-password"

        # Where netbird expects the setup key
        readonly NETBIRD_KEY_FOLDER="/var/lib/netbird-homelab"
        readonly NETBIRD_KEY_PATH="$NETBIRD_KEY_FOLDER/setup-key"

        # Create a temporary directory for extra files
        TEMP=$(mktemp -d)
        readonly TEMP

        # Function to cleanup temporary directory on exit
        function cleanup() {
          rm -rf "$TEMP"

          # Cleanup temporary password file
          if [ -f "$LOCAL_DISK_PASSWORD_PATH" ]; then
            shred -u "$LOCAL_DISK_PASSWORD_PATH"
          fi
        }


        function set_disk_password() {
          local disk_password
          disk_password=$(ask_for_token "disk encryption password")

          if [[ -z "$disk_password" ]]; then
            disk_password=$(generate_password)
            echo "Disk password auto-generated." >&2
          else
            echo "Disk password has been set." >&2
          fi

          # Create temporary password file to be passed to nixos-anywhere
          local -r tmp_folder=$(mktemp -d)
          readonly LOCAL_DISK_PASSWORD_PATH="$tmp_folder/disk-password"
          echo -n "$disk_password" >"$LOCAL_DISK_PASSWORD_PATH"
          # Create the directory where TPM expects disk password during
          # the key enrollment, it will be removed after the fisrt boot
          install -d -m755 "$TEMP/$REMOTE_DISK_PASSWORD_FOLDER"
          cp "$LOCAL_DISK_PASSWORD_PATH" "$TEMP/$REMOTE_DISK_PASSWORD_FOLDER"

          echo "Disk password successfully installed." >&2
        }

        function install_netbird_key() {
          local -r hostname="$1"

          # Check if NETBIRD_API_TOKEN is set, prompt if not
          if [ -z "''${NETBIRD_API_TOKEN:-}" ]; then
            NETBIRD_API_TOKEN=$(ask_for_token "Netbird API token")

            if [ -z "$NETBIRD_API_TOKEN" ]; then
              echo "ERROR: Netbird API token is required" >&2
              exit 1
            fi

            export NETBIRD_API_TOKEN
          fi

          echo "Generating Netbird setup key for $hostname" >&2

          # Generate ephemeral setup key using Netbird API
          # Requires NETBIRD_API_TOKEN environment variable
          local api_response
          if ! api_response=$(curl -s -X POST https://api.netbird.io/api/setup-keys \
            -H "Authorization: Token $NETBIRD_API_TOKEN" \
            -H "Content-Type: application/json" \
            --data-raw "{\"name\":\"$hostname\",\"type\":\"one-off\",\"expires_in\":86400,\"auto_groups\":[],\"usage_limit\":1,\"ephemeral\":false}" 2>&1); then
            echo "ERROR: Failed to create Netbird setup key via API" >&2
            echo "Response: $api_response" >&2
            exit 1
          fi

          # Extract the key from the API response
          local -r setup_key=$(echo "$api_response" | jq -r '.key')

          # Validate that we got a non-empty key
          if [ -z "$setup_key" ] || [ "$setup_key" = "null" ]; then
            echo "ERROR: Netbird setup key is empty or invalid" >&2
            echo "API Response: $api_response" >&2
            exit 1
          fi

          # Create directory for Netbird setup key
          install -d -m755 "$TEMP/$NETBIRD_KEY_FOLDER"
          echo "$setup_key" > "$TEMP/$NETBIRD_KEY_PATH"
          chmod 600 "$TEMP/$NETBIRD_KEY_PATH"

          echo "Netbird setup key installed for $hostname" >&2
        }

        function check_target_reachable() {
          echo -n "Checking if $TARGET is reachable... "

          if ! ping -c 1 -W 2 "$TARGET" >/dev/null 2>&1; then
            echo "FAILED"
            exit 1
          fi
          echo "OK"
        }

        function check_ssh_connection() {
          echo -n "Checking SSH connection to $TARGET... "

          if ! ssh "admin@$TARGET" exit 2>/dev/null; then
            echo "FAILED"
            exit 1
          fi
          echo "OK"
        }

        function check_secure_boot_setup_mode() {
          echo -n "Checking secure boot setup mode... "

          if ssh "admin@$TARGET" \
            'sbctl status | grep -qE "Setup Mode:.*Enabled"' 2>/dev/null; then
            echo "OK"
            return
          fi

          echo "WARNING: Target secure boot not in Setup Mode"
          read -r -p "Continue anyway? [y/N] " response

          case "$response" in
            y|Y)
              ;;
            *)
              echo "Installation aborted"
              exit 1
              ;;
          esac

        }

        function main() {

          require_hostname "$@"
          local -r hostname="$1"
          validate_hostname "$hostname"

          check_target_reachable
          check_ssh_connection
          check_secure_boot_setup_mode

          set_disk_password

          install_netbird_key "$hostname"

          # Install NixOS to the host system with our secrets
          nixos-anywhere \
            --disk-encryption-keys "$REMOTE_DISK_PASSWORD_PATH" "$LOCAL_DISK_PASSWORD_PATH" \
            --extra-files "$TEMP" \
            --flake ".#$hostname" \
            --target-host "root@$TARGET"
        }

        main "$@"
      '';
    };

  # Expose the shared library for testing
  inherit lib;

  # Tests for the shared library functions
  script-lib-test =
    pkgs.runCommand "script-lib-test" {
      buildInputs = with pkgs; [
        bash
        nix
        jq
      ];
    } ''
      set -euo pipefail

      # Create a test environment
      export HOME=$(mktemp -d)
      mkdir -p hosts/test-host
      mkdir -p hosts/another-host

      # Source the shared library
      source ${lib}

      echo "Running script library tests..."

      # Test require_hostname function
      test_require_hostname() {
        echo "Testing require_hostname..."

        # Test with no arguments (should fail)
        set +e
        (require_hostname >/dev/null 2>&1)
        local exit_code=$?
        set -e
        if [ $exit_code -ne 1 ]; then
          echo "ERROR: require_hostname should fail with no arguments"
          return 1
        fi

        # Test with arguments (should pass)
        require_hostname "test-host"

        echo "✓ require_hostname tests passed"
      }

      # Test password generation
      test_password_generation() {
        echo "Testing password generation..."

        # Test generate_password returns valid password
        local password
        password=$(generate_password 2>/dev/null)
        if [ -z "$password" ]; then
          echo "ERROR: generate_password should return a password"
          return 1
        fi
        if [ ''${#password} -lt 8 ] || [ ''${#password} -gt 16 ]; then
          echo "ERROR: generate_password should return 8-16 character password, got ''${#password}"
          return 1
        fi

        echo "✓ password generation tests passed"
      }

      # Run all tests
      test_require_hostname
      test_password_generation

      echo "All tests passed!"
      touch $out
    '';
}
